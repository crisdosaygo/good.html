"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkbang_html"] = self["webpackChunkbang_html"] || []).push([["src_vv_vanillaview_js"],{

/***/ "./src/vv/vanillaview.js":
/*!*******************************!*\
  !*** ./src/vv/vanillaview.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: function() { return /* binding */ c; },\n/* harmony export */   s: function() { return /* binding */ s; }\n/* harmony export */ });\n// eslint directives\n  /* eslint-disable no-empty */\n// vanillaview.js\n  // imports\n    const CODE = Math.random().toFixed(18);\n    const IMMEDIATE = Symbol.for(`[[IMMEDIATE]]`);\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key0.\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const JOINER            = '<link rel=join>';\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = x => ({message:`Object values not allowed here.`, x});\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.replaceChildren(); elem.appendChild(frag) }\n      insert      (frag,node) { node.replaceChildren(frag) }\n    };\n    const REMOVE_MAP        = new Map();\n    const DIV               = document.createElement('div');\n    const POS               = 'beforeend';\n    const EMPTY = '';\n    const {stringify:_STR} = JSON;\n    const JS = o => _STR(o, Replacer, EMPTY);\n    const isVV  = x => (x?.code === CODE || (x?.type && ( \n        x.type === 'MarkupObject' || x.type === 'MarkupAttrObject' \n      ))) && Array.isArray(x?.nodes);\n    const NextFunc          = () => `f${FuncCounter++}` + (Math.random()*10).toString(36).replace('.', '_');\n\n  // logging\n    //globalThis.onerror = (...v) => (console.log(v, v[0]+EMPTY, v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => !!v && (typeof v.key === 'string' || typeof v.key === 'number') && Object.getOwnPropertyNames(v).length <= 2;\n\n  // state\n    let FuncCounter = 10;\n\n  // cache \n    const cache = {};\n    let _CONFIG;\n    // deux\n\n  // main exports \n    Object.assign(s,{attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n    Object.assign(globalThis, {vanillaview: {c, s}}); \n\n    async function s(p,...v) {\n      const that = this;\n      let SystemCall = false;\n      let state, _host;\n\n      if ( p[0].length === 0 && v[0].state ) {\n        // by convention (see how we construct the template that we tag with FUNC)\n        // the first value is the state object when our system calls it\n        SystemCall = true;\n      }\n\n      const {key} = v.find(isKey) || {};\n\n      if ( SystemCall ) {\n        ({state,_host} = v.shift());\n        p.shift();\n        v = await Promise.all(v.map(val => process(that, val, state, _host)));\n        const xyz = vanillaview(p,v, {_host});\n        //xyz[Symbol.for('BANG-VV')] = true;\n        DEBUG && console.log({state}, self.__state = state);\n        return xyz;\n      } else {\n        const laterFunc = async (state, _host) => {\n          DEBUG && console.log({state}, self.__state = state);\n          v = await Promise.all(v.map(val => process(that, val, state, _host)));\n          const xyz = vanillaview(p,v, {_host});\n          //xyz[Symbol.for('BANG-VV')] = true;\n          return xyz;\n        };\n        laterFunc[IMMEDIATE] = true;\n        //laterFunc[Symbol.for('BANG-VV')] = true;\n        return laterFunc;\n      }\n    }\n\n    function c(p,...v) {\n      //console.error(`Using c (X) function. Not recommended`);\n      return vanillaview(p,v, {useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function vanillaview(p,v,{useCache:useCache=true, _host}={}) {\n      const retVal = {};\n      let instance, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        (instance = (v.find(isKey) || {}));\n        cacheKey = p.join(JOINER);\n        const {cached,firstCall} = isCached(cacheKey,v,instance);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = EMPTY;\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      // FIXME: do we need to walk through shadows here?\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        cacheKey,\n        instance,\n        to,\n        update,\n        code:CODE,\n        nodes:Array.from(frag.childNodes)\n      });\n\n      if ( useCache ) {\n        if ( instance.key !== undefined ) {\n          cache[cacheKey].instances[instance.key] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n        retVal.nodes.forEach(node => {\n          const instanceKey = instance.key+EMPTY;\n          REMOVE_MAP.set(node, {ck:cacheKey, ik: instanceKey});\n          _host.destructors.add(() => {\n            DEBUG && console.log(`Destructor running for ${_host.name} to remove vv cache keys`, {cacheKey, instanceKey});\n            if ( cacheKey && instanceKey && instanceKey !== \"undefined\" ) {\n              if ( cache[cacheKey] ) {\n                cache[cacheKey].instances[instanceKey] = null;\n              }\n            } else if ( cacheKey ) {\n              cache[cacheKey] = null;\n            }\n          });\n        });\n      }\n\n      return retVal;\n    }\n\n  // bang integration functions (modified from bang versions)\n    async function process(that, x, state, _host) {\n      if ( typeof x === 'string' ) return x;\n      else \n\n      if ( typeof x === 'number' ) return x+EMPTY;\n      else\n\n      if ( typeof x === 'boolean' ) return x+EMPTY;\n      else\n\n      if ( x instanceof Date ) return x+EMPTY;\n      else\n\n      if ( isUnset(x) ) {\n        if ( CONFIG.allowUnset ) return CONFIG.unsetPlaceholder || EMPTY;\n        else {\n          throw new TypeError(`Value cannot be unset, was: ${x}`);\n        }\n      }\n      else\n\n      if ( x instanceof Promise ) return await process(that, await x.catch(err => err+EMPTY), state, _host);\n      else\n\n      if ( x instanceof Element ) return x.outerHTML;\n      else\n\n      if ( x instanceof Node ) return x.textContent;\n      else \n\n      if ( isVV(x) ) {\n        return {code:CODE, externals: x.externals, nodes: x.nodes};\n      }\n\n      const isArray     = Array.isArray(x);\n      const isVVArray   = isArray && (x.length === 0 || isVV(x[0]));\n\n      if ( isIterable(x) ) {\n        if ( isVVArray ) {\n          return join(x);\n        // is a func array ?\n        } else if ( (x[0] instanceof Function) && ! x[0][IMMEDIATE] ) {\n          const character = funcCharacter(...x);\n          if ( _host.names.has(character) ) {\n            const {func: existingFunc, name: existingName} = _host.names.get(character);\n            if ( existingName ) {\n              DEBUG && console.log(`Name exists!`, x, existingName);\n              DEBUG && console.log(`Adding ${existingName} adder`, existingFunc);\n              _host.funcs.add(component => (component[existingName] = component[existingName] || existingFunc, existingName));\n              return existingName;\n            }\n          }\n          const randomName = NextFunc();\n          DEBUG && console.log({definedFunction: randomName, source: 1});\n\n          const func = (\n            function(ev) {\n              for( const fun of x ) {\n                try {\n                  fun(ev);\n                } catch(e) {\n                  console.warn(`Handler in func array failed`, {fun, e, ev, x});\n                }\n              }\n            }\n          );\n\n          _host.names.set(character, {name:randomName, func});\n          DEBUG && console.log(`Adding ${randomName} adder`, func, _host);\n          _host.funcs.add(component => (component[randomName] = func, randomName));\n          DEBUG && console.log('name', randomName, func);\n          return `${randomName}(event)`;\n        } else if ( x[0] instanceof Element || x[0] instanceof Node ) {\n          return {code:CODE, externals: [], nodes: x};\n        } else {\n          // if an Array or iterable is given then\n          // its values are recursively processed via this same function\n          return process(that, await Promise.all(\n            (\n              await Promise.all(Array.from(x)).catch(e => e+EMPTY)\n            ).map(v => process(that, v, state, _host))\n          ), state, _host);\n        }\n      }\n\n      const isVVK = isKey(x);\n      const isMAO = x.code === CODE && typeof x.str === \"string\";\n      if ( isVVK || isMAO || isVV(x) ) {\n        return x; // let vanillaview guardAndTransformVal handle\n      }\n\n      else \n\n      if ( x[IMMEDIATE] && Object.getPrototypeOf(x).constructor.name === 'AsyncFunction' ) {\n        return await process(that, await x(state, _host), state, _host);\n      }\n      else\n\n      if ( x[IMMEDIATE] && (x instanceof Function) ) return x(state, _host);\n      else // it's an object, of some type \n\n      if ( x instanceof Function ) {\n        const character = funcCharacter(x);\n        if ( _host.names.has(character) ) {\n          const {func: existingFunc, name: existingName} = _host.names.get(character);\n          if ( existingName ) {\n            DEBUG && console.log(`Name exists!`, x, existingName);\n            DEBUG && console.log(`Adding ${existingName} adder`, existingFunc);\n            _host.funcs.add(component => (component[existingName] = component[existingName] || existingFunc, existingName));\n            return existingName;\n          }\n        }\n        const name = NextFunc();\n        _host.names.set(character, {name, func:x});\n        DEBUG && console.log(`Adding ${name} adder`, x, _host);\n        _host.funcs.add(component => (component[name] = x, name)); \n        DEBUG && console.log({definedFunction:name, source: 2});\n        DEBUG && console.log('name', name, x);\n        return `${name}(event)`;\n      }\n\n      else\n      {\n        // State store     \n          /* so we assume an object is state and save it */\n          /* to the global state store */\n          /* which is two-sides so we can find a key */\n          /* given an object. This avoid duplicates */\n        let stateKey;\n\n        // own keys\n          // an object can specify it's own state key\n          // to provide a single logical identity for a piece of state that may\n          // be represented by many objects\n\n        if ( Object.prototype.hasOwnProperty.call(x, CONFIG.bangKey) ) {\n          stateKey = new that.StateKey(x[CONFIG.bangKey])+EMPTY;\n          // in that case, replace the previously saved object with the same logical identity\n          const oldX = that.STATE.get(stateKey);\n          that.STATE.delete(oldX);\n\n          that.STATE.set(stateKey, x);\n          that.STATE.set(x, stateKey);\n        } \n\n        else  /* or the system can come up with a state key */\n\n        {\n          const jsx = JS(x)\n          if ( that.STATE.has(x) || that.STATE.has(jsx) ) {\n            stateKey = (that.STATE.get(x) || that.STATE.get(jsx)).replace(/.json.last$/,'');\n            const lastXJSON = that.STATE.get(stateKey+'.json.last');\n            if ( jsx !== lastXJSON ) {\n              that.STATE.delete(lastXJSON); \n              if ( stateKey.startsWith('system-key') ) {\n                that.STATE.delete(stateKey);\n                const oKey = stateKey;\n                stateKey = new that.StateKey()+EMPTY;\n              }\n              that.STATE.set(stateKey, x);\n              that.STATE.set(x, stateKey);\n            }\n          } else {\n            const oKey = stateKey;\n            stateKey = new that.StateKey()+EMPTY;\n            //console.log({oKey, stateKey, block2:true, jsx});\n            that.STATE.set(stateKey, x);\n            that.STATE.set(x, stateKey);\n            /*\n              _host.funcs.add(component => {\n                let aq = Dependents.get(stateKey);\n                if ( ! aq ) {\n                  aq = new Set();\n                  Dependents.set(stateKey, aq);\n                }\n                aq.add(component);\n              });\n            */\n          }\n          that.STATE.set(jsx, stateKey+'.json.last');\n          that.STATE.set(stateKey+'.json.last', jsx);\n        }\n\n        stateKey += EMPTY;\n        return stateKey;\n      }\n    }\n\n    function funcCharacter(...x) {\n      return `${x.map(f => f.toString()).join(';')}`; \n    }\n\n    function isIterable(y) {\n      if ( y === null ) return false;\n      return y[Symbol.iterator] instanceof Function;\n    }\n\n    function isUnset(x) {\n      return x === undefined || x === null;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = location instanceof Node;\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      if ( node.shadowRoot instanceof ShadowRoot ) {\n        throw new TypeError(`Shadow not supported here currently`);\n      }\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n  // debug stuff\n    const Replacers = new Map();\n    if ( DEBUG ) {\n      window.Replacers = Replacers;\n    }\n  // end debug stuff\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        const wrappedReplacer = () => {\n          DEBUG && console.group(`Replacer calling for ${key}`);\n          try {\n            replacer(val.val);\n          } catch(error) {\n            console.warn(`Error in replacer for key ${key}`, {val, error});\n          }\n          DEBUG && console.log(`Replacer called for ${key}`);\n          Replacers.delete(key);\n          DEBUG && console.groupEnd();\n        };\n        externals.push(wrappedReplacer);\n        Replacers.set(key, wrappedReplacer);\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"vanillaviewobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          if ( sameOrder(oldNodes,newVal.nodes) ) {\n            // do nothing\n          } else {\n            // perf\n              // list updates could be possible more efficient\n              // this is if we are inserting new nodes\n              // but I can't imagine a way to do it that's not:\n              // 1) quadratic (edit distance)\n              // 2) lots of heuristics (did we insert a new node or nodes at the front? OK...etc...)\n            const LEGACY = false;\n            if ( LEGACY ) {\n              Array.from(newVal.nodes).reverse().forEach(n => {\n                lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n                state.lastAnchor = lastAnchor.nextSibling;\n              });\n              state.lastAnchor = newVal.nodes[0];\n            } else {\n              const insertable = [];\n              Array.from(newVal.nodes).forEach(node => {\n                const inserted = document.contains(node.ownerDocument);\n                if ( ! inserted ) {\n                  insertable.push(node);\n                } else {\n                  while( insertable.length ) {\n                    const insertee = insertable.shift();\n                    node.parentNode.insertBefore(insertee, node);\n                  }\n                }\n              });\n              while ( insertable.length ) {\n                const insertee = insertable.shift();\n                lastAnchor.parentNode.insertBefore(insertee,lastAnchor);\n              }\n              state.lastAnchor = newVal.nodes[newVal.nodes.length-1];\n            }\n          }\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        // if nodes are not included we can just remove them\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          const killSet = new Set();\n          dn.forEach(n => {\n            f.appendChild(n);\n            if ( n.linkedCustomElement ) {\n              f.appendChild(n.linkedCustomElement);\n            }\n            if ( n.nodeType === Node.COMMENT_NODE && n.textContent.match(/key\\d+/) ) return;\n            const kill = REMOVE_MAP.get(n);\n            if ( kill ) {\n              killSet.add(JS(kill));\n              // NOTE:\n              // this next line is essential\n                // it checks which other VV fragments are descendents of the node being removed. And for each of those\n                // it adds the cache Keys of that fragment to the kill set, so their caches will also be killed\n                // this essential line prevents the re-rendering of cached components that are meant to be on-screen into \n                // off-screen detached fragments, which occurs if we don't kill these caches, because their caches\n                // would indicate they need to be re-rendered at their insertion point, instad of re-created anew\n              const deps = [...REMOVE_MAP.entries()].forEach(([vvNode, k]) => n.contains(vvNode) && killSet.add(JS(k)));\n            } else {\n              DEBUG && console.warn(`No kill signature for`, n, REMOVE_MAP);\n            }\n          });\n          killSet.forEach(kill => {\n            const {ck: cacheKey, ik: instanceKey} = JSON.parse(kill);\n            try {\n              if ( cacheKey && instanceKey && instanceKey !== \"undefined\" ) {\n                if ( cache[cacheKey] ) {\n                  cache[cacheKey].instances[instanceKey] = null;\n                }\n              } else if ( cacheKey ) {\n                cache[cacheKey] = null;\n              }\n            } catch(e) {\n              console.warn(`Error in kill for`, {kill, cacheKey, instanceKey});\n            }\n          });\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function sameOrder(nodesA, nodesB) {\n        if ( nodesA.length != nodesB.length ) return false;\n\n        return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        if ( node.linkedCustomElement && newValue !== oldVal ) {\n          updateLinkedCustomElement(node);\n        }\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function updateLinkedCustomElement(node) {\n        const lce = node.linkedCustomElement;\n        const span = toDOM(`<span ${node.textContent}></span>`).firstChild;\n        //FIXME: may have to look at this for the combination of vv and bang, may not need to remove these\n        const toRemove = new Set(\n          getAttributes(lce)\n            .filter(({name}) => !name.startsWith('on'))\n            .map(({name}) => name)\n        );\n        getAttributes(span).forEach(({name, value}) => {\n          if ( name === lce.localName ) return; // i.e., it's the bang tag name\n          if ( name.startsWith('on') ) return; // we don't handle event handlers here, that's in bang\n          lce.setAttribute(name, value);\n          toRemove.delete(name);\n        });\n        toRemove.forEach(name => lce.removeAttribute(name));\n      }\n\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : EMPTY\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        const updater = (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"vanillaviewobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n        // call it the first time so it loads well\n        // and we elide out the key placeholders here\n        updater(scope.val.val);\n        return updater;\n      }\n\n  // helpers\n    function Replacer(key, value) {\n      const obj = this;\n      if ( typeof obj[key] === \"function\" ) {\n        return value.toString();\n      } else if ( value instanceof Node ) {\n        return `${value.nodeName}//${value.nodeValue || value.outerHTML || value.textContent}`;\n      } else return value;\n    }\n\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      return Array.from(node.attributes);\n      /*\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n      */\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n        reliablySetAttribute(node, name, EMPTY);\n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && typeof oldVal === 'object'  ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths,oldAttrVal} = scope;\n\n      let attr = node.getAttribute(name);\n      let newAttrValue;\n\n      if ( oldAttrVal === oldVal ) {\n        // if we are setting old val to be the whole attribute value\n        // then we can just splice it in by setting it easily\n        newAttrValue = newVal;\n      } else {\n        // otherwise we need to carefully calculate everything\n        let zeroWidthCorrection = 0;\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n          \n        // we need to trim newVal to have parity with classlist add\n          // the reason we have zeroWidthCorrection = -1\n          // is because the classList is a set of non-zero width tokens\n          // separated by spaces\n          // when we have a zero width token, we have two adjacent spaces\n          // which, by virtue of our other requirement, gets replaced by a single space\n          // effectively elliding out our replacement location\n          // in order to keep our replacement location in tact\n          // we need to compensate for the loss of a token slot (effectively a token + a space)\n          // and having a -1 correction effectively does this.\n        if ( name == \"class\" ) {\n          newVal = newVal.trim();\n          if ( newVal.length == 0 ) {\n            zeroWidthCorrection = -1;\n          }\n          scope.val.val = newVal;\n        }\n        lengths[valIndex] = newVal.length + zeroWidthCorrection;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = attr.slice(0,index+correction);\n        const after = attr.slice(index+correction+oldVal.length);\n        \n        if ( name == \"class\" ) {\n          const spacer = oldVal.length == 0 ? ' ' : EMPTY;\n          newAttrValue = before + spacer + newVal + spacer + after;\n        } else {\n          newAttrValue = before + newVal + after;\n        }\n      }\n\n      if ( attr !== newAttrValue ) {\n        reliablySetAttribute(node, name, newAttrValue);\n      }\n\n      scope.oldVal = newVal;\n      scope.oldAttrVal = newAttrValue;\n    }\n\n    function reliablySetAttribute(node, name, value, /*{funcValue} = {}*/) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      const oName = name;\n      let modifiers;\n\n      if ( modifiers ) {\n        modifiers = Object.fromEntries(modifiers.map(m => ([m, true])));\n        DEBUG && console.warn(\"not handling modifiers currently\", {node, name, value, modifiers});\n        //node.addEventListener(name, funcValue, modifiers);\n      }\n\n      if ( CONFIG.EVENTS.includes('on'+name) ) {\n        name = 'on'+name;\n\n        const existingValue = node.getAttribute(name);\n        if ( node.getRootNode().host ) {\n          //console.log(node, [...node.getRootNode().host.paths.keys()]);\n          if ( node.getRootNode().host.paths.has(existingValue) ) {\n            DEBUG && console.log('Not running replacement again for', {node, name, oName, value, existingValue});\n            return;\n          }\n        } else {\n          DEBUG && console.warn(`No host exists yet`);\n          if ( existingValue?.startsWith('this.') ) {\n            DEBUG && console.log('Not running replacement again for', {node, name, oName, value, existingValue});\n            return;\n          }\n        }\n      }\n\n      try {\n        node.setAttribute(name,isUnset(value) ? name : value);\n      } catch(e) {\n        console.warn(`error`, e, {node, name, value});\n      }\n      // if you set style like this is fucks it up\n      if ( name in node && name !== 'style' ) {\n        try {\n          node[name] = isUnset(value) ? true : value;\n        } catch(e) {\n        }\n      }\n    }\n\n    function getType(val) {\n      const to = typeof val;\n      const type = to === 'function' ? 'function' :\n        val.code === CODE && Array.isArray(val.nodes) ? 'vanillaviewobject' : \n        val.code === CODE && typeof val.str === 'string' ? 'markupattrobject' :\n        Array.isArray(val) && (val.length === 0 || (\n          val[0].code === CODE && Array.isArray(val[0].nodes) \n        )) ? 'vanillaviewarray' : \n        Array.isArray(val) && (val.length === 0 || (\n          typeof val[0] === 'function'\n        )) ? 'funcarray' : \n        to === 'object' ? 'handlers' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.isConnected && \n          node.nodeType == Node.COMMENT_NODE && \n          node.nodeValue == 'vanillaview_placeholder' \n        );\n      if ( ! ph ) {\n        ph = toDOM(`<!--vanillaview_placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instance) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instance.key !== undefined ) {\n            cached.instances = {};\n            cached = cached.instances[instance.key] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instance.key !== undefined ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instance.key];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                if ( instance.kill === true ) {\n                  cached = cache[cacheKey]; \n                  if ( cached && cached.instances ) {\n                    cached.instances[instance.key] = null;\n                  }\n                  cached = null;\n                  firstCall = true;\n                } else {\n                  firstCall = false;\n                }\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        //console.log({cached,firstCall,instance});\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that VanillaView treats as markup,\n      // even tho it is NOT a VanillaView Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = isUnset(str) ? EMPTY : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:Array.from(frag.childNodes),\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that VanillaView treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = isUnset(str) ? EMPTY : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( isUnset(val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( isKey(val) ) {\n            return EMPTY;\n          }\n          const key = 'key'+Math.random().toFixed(15);\n          let k = key;\n          if ( val.code === CODE && Array.isArray(val.nodes) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        DIV.replaceChildren();\n        DIV.insertAdjacentHTML(POS, `<template>${str}</template>`);\n        return DIV.firstElementChild.content;\n      }\n\n      function guardAndTransformVal(v) {\n        const isVVArray   = Array.isArray(v) && (v.length === 0 || isVV(v[0]));\n        const isNotSet         = isUnset(v);\n        const isForgery = v.code !== CODE && Array.isArray(v.nodes);\n        const isObject        = typeof v === 'object';\n\n        if ( isVVArray )      return join(v); \n        if ( isKey(v) )           return v;\n        if ( v.code === CODE )    return v;\n\n        if ( isNotSet )            die({error: UNSET()});\n        if ( isForgery )          die({error: XSS()});\n\n        if ( Array.isArray(v) && v[0] instanceof Node ) {\n          return {code:CODE, nodes: v, externals: []};\n        }\n\n        if ( Array.isArray(v) && v[0] instanceof Function ) {\n          return v;\n        }\n\n        if ( isObject ) die({error: OBJ(v)});\n\n        return v+EMPTY;\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        for( const o of os ) {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        }\n        const retVal = {v,code:CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"vanillaviewobject\":\n              // the vanillaview object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"vanillaviewarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JS(oldVal) !== JS(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw msg;\n    }\n\n\n//# sourceURL=webpack://bang.html/./src/vv/vanillaview.js?\n}");

/***/ })

}]);